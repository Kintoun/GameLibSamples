Code designs:

Game loop management:
-Create states which are pushed and popped.
	-https://github.com/FRex/Man
	-For example the main menu is just a state that is pushed initially, then depending on button presses new states are pushed on top of those.
	-Each state is like a game loop of it's own with keys and window.
	-There is a state manager which calls run on the states.
	-Pausing is just another state that is pushed on top of the game itself
-Split window poll events and game engine events up.
	-https://github.com/FRex/Man
	-while(window->pollEvent) then while(engine.pollEvent)
	
Decoupling:
http://www.gamedev.net/page/resources/_/technical/game-programming/managing-decoupling-r3034
-Avoid frameworks, they create coupling.
-Let the high level systems communicate instead of low level systems. Creates coupling in one place.
-Use IDs and look them up. Lets you pass around objects all over the place easily.
-Don't stress out too much about type casting. 99% of the time it will crash and be fixed.

Component models:
-the power of a component system comes from how you integrate it with script and data

Interpolation with speed/movement:
-If I am updating 25 times per sec, yet I am rendering at 50 FPS, then I can update 25 times, and draw twice between updates.
-The update code sets the game tick position of the player. The render code sets the position of the sprite that represents the player.
-In the case with 2 render calls per game update (25 ticks per sec, 50 FPS), When the player holds forward, we move forward X units in game logic.
 However in render logic since we know we get 2 render calls, we move the SPRITE forward x/2 units, call render, then x/2 again and call render again (2 renders).
-Collisions, physics, etc work off of the game state pos, NOT the sprite position (render pos). There is no "lag" per-se. In fact we vastly smooth things out.
-Imagine the case where we update 25 times per sec, but render at uncapped, say 1000, FPS. Our animations would be dead smooth, but our game logic wouldn't be
 overburdened since it is only working at the rate of 25 ticksPerSec. The main game loop calculates the interpolation between 2 game ticks, and uses that information
 to smooth out the rendering between game ticks.